<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>紙ヒコーキゲーム（隠し無敵モード）</title>
<style>
  body { 
    margin:0; background:#000; display:flex; flex-direction:column; 
    align-items:center; color:#fff; font-family:monospace; position: relative;
  }
  canvas { background:#000; touch-action:none; }
  #controls {
    margin-top: 10px; font-size: 14px; text-align: center; color: #0f0;
  }
  .cat {
    position: absolute; width: 120px; pointer-events: none;
  }
</style>
</head>
<body>
  <canvas id="game" width="320" height="480"></canvas>
  <div id="controls">
    PC: ← / → で操作, Spaceでリスタート<br>
    スマホ: 左タップ=左, 右タップ=右, タップでリスタート
  </div>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// --- 背景 ---
const bg1 = new Image(); bg1.src = "bg1.png";
const bg2 = new Image(); bg2.src = "bg2.png";
let bgY = 0;

// --- 背景フィルター（ステージ1のみ） ---
const bgFilters = [
  "rgba(255,0,0,0.3)","rgba(0,255,0,0.3)","rgba(0,0,255,0.3)",
  "rgba(255,255,0,0.3)","rgba(255,0,255,0.3)","rgba(0,255,255,0.3)",
  "rgba(255,255,255,0.2)"
];
let bgFilterIndex = 0;

// --- 紙ヒコーキ色（ステージ2で変化） ---
const planeColors = ["#fff","#ff0","#0ff","#f0f","#0f0","#f00","#00f"];
let planeColor = "#fff";

// --- 入力 ---
let keys = {};
document.addEventListener("keydown", e => {
  if(!keys[e.code]){
    if(e.code==="ArrowLeft"||e.code==="KeyA"){ plane.angle=Math.max(plane.angle-0.3,-1.2); }
    if(e.code==="ArrowRight"||e.code==="KeyD"){ plane.angle=Math.min(plane.angle+0.3,1.2); }
  }
  keys[e.code]=true;
  if(e.code==="Space"&&(state==="gameover"||state==="goal")){ restartGame(); }
  if(e.code==="Digit0"){ invincible=!invincible; } // ★隠し無敵モード
});
document.addEventListener("keyup", e=>keys[e.code]=false);

// --- タッチ操作 ---
canvas.addEventListener("touchstart", e=>{
  const touch=e.touches[0];
  const rect=canvas.getBoundingClientRect();
  const x=touch.clientX-rect.left;
  if(state==="gameover"||state==="goal"){ restartGame(); return; }
  if(x<canvas.width/2){ plane.angle=Math.max(plane.angle-0.3,-1.2); }
  else { plane.angle=Math.min(plane.angle+0.3,1.2); }
});

// --- 紙ヒコーキ ---
const plane={x:160,y:400,scale:2.0,speed:0.018,angle:0,vx:0};

// --- データ ---
let walls=[]; let characters=[]; let lastSpawn=0;
let spawnInterval=1600; let scrollSpeed=0.8; let gapW=140;

// --- 状態 ---
let state="running"; let score=0; let level=1; let stage=1; let goalTapeTime=0;
let invincible=false;

// --- 犬スピード倍率 ---
let dogSpeedFactor = 1;

// --- 猫GIF ---
function spawnCat(){
  const img=document.createElement("img");
  img.src="cat.gif"; img.className="cat";
  img.style.left=canvas.offsetLeft+(20+Math.random()*(canvas.width-120))+"px";
  img.style.top=canvas.offsetTop-120+"px";
  document.body.appendChild(img);
  let y=-120; let speed=3+Math.random()*5;
  const interval=setInterval(()=>{
    y+=speed; img.style.top=canvas.offsetTop+y+"px";
    if(y>canvas.height+120){ clearInterval(interval); img.remove(); }
  },30);
}

// --- ループ ---
let lastTime=performance.now();
function loop(now){ const dt=now-lastTime; lastTime=now; update(now,dt); render(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// --- 更新 ---
function update(now,dt){
  if(state!=="running") return;
  plane.vx+=plane.angle*plane.speed*dt;
  plane.vx*=0.85; plane.x+=plane.vx;
  plane.x=Math.max(10,Math.min(canvas.width-10,plane.x));

  if(stage===1){
    if(now-lastSpawn>spawnInterval){
      let gapX=40+Math.random()*(canvas.width-160);
      walls.push({y:-40,gapX,gapW,h:30,passed:false});
      lastSpawn=now;
    }
    for(let w of walls){
      w.y+=scrollSpeed;
      if(!w.passed&&w.y>plane.y){
        score++; w.passed=true;
        if(score%10===0){
          level++; scrollSpeed+=0.1;
          spawnInterval=Math.max(600,spawnInterval-80);
          gapW=Math.max(60,gapW-8); plane.speed+=0.003;
          bgFilterIndex=Math.floor(Math.random()*bgFilters.length);
        }
        if(score%20===0){
          let count=2+Math.floor(Math.random()*3);
          for(let i=0;i<count;i++){ setTimeout(spawnCat,i*400); }
        }
      }
      if(plane.y<w.y+w.h&&plane.y+15>w.y){
        if(plane.x<w.gapX||plane.x>w.gapX+gapW){ if(!invincible) state="gameover"; }
      }
    }
    walls=walls.filter(w=>w.y<canvas.height+80);
    if(score>=stage*100){ state="goal"; goalTapeTime=performance.now(); setTimeout(()=>nextStage(),2000); }
  } else if(stage===2){
    if(now-lastSpawn>spawnInterval){
      characters.push({
        x:40+Math.random()*(canvas.width-80),
        y:-60, size:50,
        vx:(Math.random()<0.5?-1:1)*(0.05+Math.random()*0.1)*dogSpeedFactor,
        passed:false
      });
      lastSpawn=now; spawnInterval=2000+Math.random()*1000;
    }
    for(let c of characters){
      c.y+=scrollSpeed; c.x+=c.vx;
      if(c.x<20||c.x>canvas.width-20) c.vx*=-1;
      if(!c.passed&&c.y>plane.y){
        score++; c.passed=true;
        if(score%10===0){
          dogSpeedFactor *= 1.2;
          planeColor=planeColors[Math.floor(Math.random()*planeColors.length)];
        }
      }
      if(Math.abs(plane.x-c.x)<c.size/2&&Math.abs(plane.y-c.y)<c.size/2){
        if(!invincible) state="gameover";
      }
    }
    characters=characters.filter(c=>c.y<canvas.height+100);
    if(score>=200){ state="goal"; goalTapeTime=performance.now(); }
  }
}

// --- 再スタート ---
function restartGame(){
  walls=[]; characters=[]; score=0; level=1; stage=1;
  lastSpawn=performance.now(); scrollSpeed=0.8; spawnInterval=1600; gapW=140;
  plane.x=160; plane.vx=0; plane.angle=0; plane.speed=0.018;
  state="running"; bgFilterIndex=0; planeColor="#fff"; invincible=false;
  dogSpeedFactor=1;
}

// --- 次のステージ ---
function nextStage(){
  stage++; walls=[]; characters=[]; lastSpawn=performance.now();
  scrollSpeed=0.2; spawnInterval=2000; gapW=140; dogSpeedFactor=1;
  plane.x=160; plane.vx=0; plane.angle=0; state="running"; bgFilterIndex=0; planeColor="#fff";
}

// --- 描画 ---
function render(){
  if(stage===1) drawBackgroundStage1(); else if(stage===2) drawBackgroundStage2();
  if(stage===1){
    ctx.fillStyle="#333";
    for(let w of walls){
      ctx.fillRect(0,w.y,w.gapX,w.h);
      ctx.fillRect(w.gapX+gapW,w.y,canvas.width-(w.gapX+gapW),w.h);
    }
  }
  for(let c of characters){ drawDog(c.x,c.y,c.size); }
  drawPaperPlane(plane.x,plane.y,plane.scale,plane.angle);

  ctx.fillStyle="#fff"; ctx.font="16px monospace";
  ctx.fillText("SCORE:"+score,10,20);
  ctx.fillText("STAGE:"+stage,10,40);
  ctx.fillText("LV:"+level,250,20);

  if(state==="goal"){
    if(performance.now()-goalTapeTime<800){
      ctx.fillStyle="#f00"; ctx.fillRect(0,plane.y-8,canvas.width,8);
    }
    ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle="#0f0"; ctx.font="24px monospace";
    ctx.fillText("GOAL!!",110,200); ctx.fillText("STAGE "+stage+" CLEAR",70,240);
  }
  if(state==="gameover"){
    ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle="#fff"; ctx.font="20px monospace";
    ctx.fillText("GAME OVER",100,220); ctx.fillText("TAP or SPACE to Restart",40,260);
  }
}

// --- 背景 ---
function drawBackgroundStage1(){
  ctx.drawImage(bg1,0,bgY,canvas.width,canvas.height);
  ctx.drawImage(bg1,0,bgY-canvas.height,canvas.width,canvas.height);
  ctx.fillStyle=bgFilters[bgFilterIndex]; ctx.globalCompositeOperation="overlay";
  ctx.fillRect(0,0,canvas.width,canvas.height); ctx.globalCompositeOperation="source-over";
  bgY+=scrollSpeed*0.5; if(bgY>=canvas.height) bgY=0;
}
function drawBackgroundStage2(){
  ctx.drawImage(bg2,0,bgY,canvas.width,canvas.height);
  ctx.drawImage(bg2,0,bgY-canvas.height,canvas.width,canvas.height);
  bgY+=scrollSpeed*0.5; if(bgY>=canvas.height) bgY=0;
}

// --- 紙ヒコーキ ---
function drawPaperPlane(cx,cy,scale,angle){
  ctx.save(); ctx.translate(cx,cy); ctx.scale(scale,scale); ctx.rotate(angle);
  ctx.fillStyle=planeColor; ctx.beginPath();
  ctx.moveTo(0,-10); ctx.lineTo(-8,10); ctx.lineTo(8,10); ctx.closePath(); ctx.fill();
  ctx.strokeStyle="#999"; ctx.stroke();
  ctx.strokeStyle="#aaa"; ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(0,10); ctx.stroke();
  ctx.fillStyle="rgba(0,0,0,0.2)"; ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(8,10); ctx.lineTo(0,10); ctx.closePath(); ctx.fill();
  ctx.restore();
}

// --- 犬キャラ ---
function drawDog(cx,cy,size){
  ctx.save(); ctx.translate(cx,cy); ctx.fillStyle="#c96"; ctx.beginPath();
  ctx.arc(0,0,size*0.5,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#a52a2a"; ctx.beginPath();
  ctx.ellipse(-size*0.35,-size*0.2,size*0.2,size*0.35,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(size*0.35,-size*0.2,size*0.2,size*0.35,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#000"; ctx.beginPath();
  ctx.arc(-size*0.15,-size*0.1,size*0.08,0,Math.PI*2);
  ctx.arc(size*0.15,-size*0.1,size*0.08,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(0,0,size*0.1,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
</script>
</body>
</html>
